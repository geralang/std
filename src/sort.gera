
mod std::sort

use std::iter::*
use std::opt::*
use std::rng::Random

pub proc ascending(f) {
    return |a, b| f(a) - f(b)
}

pub proc descending(f) {
    return |a, b| f(b) - f(a)
}  

pub proc quicksort(src, start, end, comp) {
    case end - start <= 1 -> return unit
    var some_comp_val = comp(src[start], src[end - 1])
    var zero = some_comp_val - some_comp_val
    var current = {
        left = start,
        right = end - 1
    }
    var pivot = src[Random::int_in(current.left, current.right)]
    exhaust(|| {
        current.left = current.left..=current.right
            |> find(|l| comp(src[l], pivot) >= zero)
            |> expect("'l' is guaranteed to meet the pivot")
        current.right = current.right..=current.left
            |> find(|r| comp(src[r], pivot) <= zero)
            |> expect("'r' is guaranteed to meet the pivot")
        case src[current.left] == pivot && src[current.right] == pivot
            -> return #end unit
        var moved = src[current.left]
        src[current.left] = src[current.right]
        src[current.right] = moved
        return #next unit
    })
    quicksort(src, start, current.left, comp)
    quicksort(src, current.right + 1, end, comp)
}