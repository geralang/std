
mod std::iter

use std::opt

pub proc map(iter, mapping) = || {
    case iter() {
        #next n -> return #next mapping(n)
    } else return #end unit
}

pub proc filter(iter, condition) = || {
    mut var result = #end unit
    exhaust(|| {
        var current
        case iter() {
            #next n -> current = n
        } else return #end unit
        case condition(current) -> {
            result = #next current
            return #end unit
        }
        return #next unit
    })
    return result
}

pub proc reduce(iter, reduction, initial) {
    mut var acc = initial
    iter |> map(-> {
        acc = reduction(acc, it)
    }) |> exhaust()
    return acc
}

pub proc take(iter, n) {
    mut var i = 0
    return || {
        case i >= n -> return #end unit
        i = i + 1
        return iter()
    }
}

pub proc take_while(iter, cond) {
    mut var done = false
    return || {
        case done -> return #end unit
        var value
        case iter() {
            #next n -> value = n
        } else return #end unit
        case cond(value) -> return #next value
        done = true
        return #end unit
    }
}

pub proc skip(iter, n) {
    iter |> take(n) |> exhaust()
    return iter
}

pub proc for_each(iter, action) = iter
    |> map(action)
    |> exhaust()

pub proc zip(iter_a, iter_b, combinator) = || {
    var val_a
    case iter_a() {
        #next v -> val_a = v
    } else return #end unit
    var val_b
    case iter_b() {
        #next v -> val_b = v
    } else return #end unit
    return #next combinator(val_a, val_b)
}

pub proc chain(iter_a, iter_b) = || {
    case iter_a() {
        #next n -> return #next n
    } else return iter_b()
}

pub proc count(iter) = iter
    |> reduce(|count, e| count + 1, 0)

pub proc next(iter) {
    case iter() {
        #next v -> return #some v
    } return #none unit
}

pub proc last(iter) {
    mut var result = #none unit
    iter |> for_each(|v| {
        result = #some v
    })
    return result
}

pub proc find(iter, condition) = iter
    |> filter(condition)
    |> next()

pub proc find_last(iter, condition) = iter
    |> filter(condition)
    |> last()

pub proc enumerate(iter) {
    mut var i = 0
    return iter |> map(|v| {
        var ci = i
        i = i + 1
        return { idx = ci, val = v }
    })
}

pub proc has(iter, element) = iter
    |> find(|e| e == element)
    |> opt::is_some()

pub proc empty() = || #end unit

pub proc over_value(v) {
    mut var done = false
    return || {
        case done -> return #end unit
        done = true
        return #next v
    }
}

pub proc repeat_over(f) = || #next f()