
mod std::str

use std::(iter, opt, math, res)

pub proc substring_until(s, end_index) {
    return s |> substring(0, end_index)
}

pub proc substring_after(s, start_index) {
    return s |> substring(start_index, s |> length())
}

pub proc at(s, index) {
    return s |> substring(index, index + 1)
}

pub proc starts_with(s, prefix) {
    case length(prefix) > length(s) -> return false
    var compared_prefix = s
        |> substring_until(length(prefix))
    return compared_prefix == prefix
}

pub proc ends_with(s, suffix) {
    case length(suffix) > length(s) -> return false
    var compared_suffix = s
        |> substring_after(-length(suffix))
    return compared_suffix == suffix
}

pub proc find(s, sub) {
    var current = { index = 0 }
    return || {
        mut var found = { value = #end unit }
        exhaust(|| {
            case current.index > length(s) - length(sub) -> return #end unit
            var c = current.index
            current.index = current.index + 1
            var compared_sub = s |> substring(c, c + length(sub))
            case compared_sub == sub -> {
                found.value = #next c
                return #end unit
            }
            return #next unit
        })
        return found.value
    }
}

pub proc pad_left(s, target_length, padding) {
    var fill_length = target_length - length(s)
    return padding
        |> string(math::max(fill_length / length(padding), 0))
        |> concat(padding |> substring_until(fill_length % length(padding)))
        |> concat(s)
}

pub proc pad_right(s, target_length, padding) {
    var fill_length = target_length - length(s)
    return s
        |> concat(padding |> string(math::max(fill_length / length(padding), 0)))
        |> concat(padding |> substring_until(fill_length % length(padding)))
}

pub proc fmt(s, v) {
    var current = { ci = 0, vi = 0, rs = s }
    exhaust(|| {
        case current.ci >= length(current.rs) -> return #end unit
        case current.vi >= length(v) -> return #end unit
        var ci = current.ci
        case at(current.rs, ci) == "_" -> {
            var inserted = v[current.vi]
            current.rs = current.rs
                |> substring_until(ci)
                |> concat(inserted)
                |> concat(current.rs |> substring_after(ci + 1))
            current.ci = ci + length(inserted)
            current.vi = current.vi + 1
        } else {
            current.ci = ci + 1
        }
        return #next unit
    })
    case current.vi < length(v) -> {
        "the format string '_' does not \
contain enough underscores for _ value(s)"
            |> fmt([s, v |> length() |> as_str()])
            |> panic()
    }
    return current.rs
}

pub proc split(s, separator) {
    var current = {
        anchor = 0,
        done = false
    }
    var until_length = length(s) - length(separator)
    return || {
        case current.done -> return #end unit
        var next_split
        case current.anchor <= until_length
            -> next_split = current.anchor..=until_length
                |> iter::find(|index| 
                    substring(s, index, index + length(separator)) == separator
                ) 
        else next_split = #none unit
        case next_split {
            #none -> {
                var result = s |> substring_after(
                    math::min(current.anchor, length(s))
                )
                current.anchor = length(s)
                current.done = true
                return #next result
            }
            #some i -> {
                var result = s |> substring(current.anchor, i)
                current.anchor = i + length(separator)
                return #next result
            }
        }
    }
}

pub proc join(strings, separator) {
    mut var result = {
        value = "",
        had_part = false
    }
    strings |> iter::for_each(|s| {
        case result.had_part
            -> result.value = result.value |> concat(separator)
        result.value = result.value |> concat(s)
        result.had_part = true
    })
    return result.value
}

pub proc iter(s) {
    return 0..length(s)
        |> iter::map(|i| s |> at(i))
}

proc parse_digit(c) {
    var d
    case c {
        "0" -> d = 0  "1" -> d = 1  "2" -> d = 2
        "3" -> d = 3  "4" -> d = 4  "5" -> d = 5
        "6" -> d = 6  "7" -> d = 7  "8" -> d = 8
        "9" -> d = 9
    } else return #err unit
    return #ok d
}

pub proc parse_int(source) {
    case length(source) == 0 -> return #none unit
    mut var start = 0
    mut var sign = 1
    case at(source, 0) == "-" -> {
        case length(source) == 1 -> return #none unit
        sign = -1
        start = 1
    }
    return start..length(source)
        |> iter::map(|i| source |> at(i))
        |> iter::reduce(|r, c| r |> res::and_then(|v|
            parse_digit(c)
                |> res::map(|d| v * 10 + d)
        ), #ok 0)
        |> res::map(|r| #some r * sign)
        |> res::unwrap_or(#none unit)
}

pub proc parse_flt(source) {
    case length(source) == 0 -> return #none unit
    var dot
    case source |> find(".") |> iter::next() {
        #none -> return source
            |> parse_int()
            |> opt::map(as_flt)
        #some d -> dot = d
    }
    var whole
    case source |> substring_until(dot) |> parse_int() {
        #none -> whole = 0.0
        #some w -> whole = w |> as_flt()
    }
    return 1..(length(source) - dot)
        |> iter::reduce(|r, i| r |> res::and_then(|v|
            source
                |> at(i + dot)
                |> parse_digit()
                |> res::map(|d| v
                    + as_flt(d) * math::pow(10.0, -as_flt(i))
                )
        ), #ok 0.0)
        |> res::map(|f| #some std::if_else(
            at(source, 0) != "-", whole + f, whole - f
        ))
        |> res::unwrap_or(#none unit)
}